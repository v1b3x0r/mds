# Layer 1: Ontology
> Being & Knowing - Memory, Emotion, Relationships, Intent

## What & Why
Defines what it means to "be" and "know."
Entities aren't just physicsâ€”they remember, feel, relate, and desire.

## Philosophy
"Essence-first, not state-first"
- Memory = What I've experienced
- Emotion = How I feel (PAD model)
- Relationships = Who I know
- Intent = What I want (goal stack)

Systems are independent but compose naturally.

## Structure
```
1-ontology/
â”œâ”€â”€ memory/
â”‚   â”œâ”€â”€ buffer.ts           # Ebbinghaus decay
â”‚   â”œâ”€â”€ consolidation.ts    # Long-term storage
â”‚   â””â”€â”€ crystallization.ts  # Pattern extraction
â”œâ”€â”€ emotion/
â”‚   â”œâ”€â”€ state.ts            # PAD model (Pleasure-Arousal-Dominance)
â”‚   â””â”€â”€ detector.ts         # Text â†’ emotion (Thai/English)
â”œâ”€â”€ relationships/
â”‚   â”œâ”€â”€ bond.ts             # Trust, familiarity
â”‚   â””â”€â”€ decay.ts            # Time-based forgetting
â””â”€â”€ intent/
    â”œâ”€â”€ intent.ts           # Goal stack (approach, avoid, etc.)
    â””â”€â”€ reasoner.ts         # Context-aware scoring
```

## Dependencies
âœ… Can import: 0-foundation, schema, itself
âŒ Cannot import: 2-physics, 3-cognition, 4-communication, 5-network, 6-world, 7-interface
ğŸ”„ Used by: Everyone (ontology is fundamental)

## Key Patterns
**Memory:** `memory.add({ type, subject, content, salience })` â†’ Ebbinghaus decay
**Emotion:** PAD model (valence, arousal, dominance) + drift to baseline
**Relationships:** `createRelationship()` â†’ trust/familiarity + decay over time
**Intent:** Stack with priorities â†’ `current()` returns highest priority goal
**Reasoning:** `reasonAbout(intent, context)` â†’ weighted scoring (emotion + memory + relationships)

## Anti-Patterns
âŒ Mix with rendering (emotion â†’ color belongs elsewhere)
âŒ Assume physics exists (ontology is abstract)
âŒ Hardcode language (support Thai/English)
âŒ Couple systems tightly (memory works without emotion)

## Common Tasks
**Add emotion:** `entity.enableEmotion({ baseline, driftRate })`
**Query memories:** `memory.recall({ type, subject, limit })`
**Detect emotion:** `detectEmotionFromText('à¸”à¸µà¹ƒà¸ˆ', 'th')`
**Reason intent:** `reasonAbout(intent, { emotion, memory, relationships })`

## Notes for AI
- Subsystems are composable (work alone or together)
- PAD model = continuous emotion space (smooth blending)
- Ebbinghaus: Recent + salient memories recalled easier
- Intent = declarative goals, not commands
- Support multilingual (Thai priority)
